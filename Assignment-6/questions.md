1. How does the remote client determine when a command's output is fully received from the server, and what techniques can be used to handle partial reads or ensure complete message transmission?

_In a networked shell over TCP, the remote client determines that a command’s output is fully received by relying on application-level framing. A common approach is for the server to send a unique marker—such as an EOF character or a designated token—once the command’s output is complete. The client, which reads data in a loop due to TCP’s stream nature (which might deliver data in partial chunks), checks for this marker to decide when to stop reading. Alternatively, the protocol can specify a header that indicates the length of the output, so the client knows exactly how many bytes to expect. These techniques help to ensure that even when the output is split across several TCP packets, the client can reassemble the entire message reliably._

2. This week's lecture on TCP explains that it is a reliable stream protocol rather than a message-oriented one. Since TCP does not preserve message boundaries, how should a networked shell protocol define and detect the beginning and end of a command sent over a TCP connection? What challenges arise if this is not handled correctly?

_Because TCP is a continuous, reliable stream that does not preserve the boundaries of messages, a networked shell protocol must explicitly define the start and end of each command or response. This can be done by using either length-prefixed messages or specific delimiters. In a length-prefixed protocol, each message begins with a fixed-size header that indicates the number of bytes in the message, so the receiver can read the header first and then read the exact number of bytes that follow. With a delimiter-based approach, a unique string or character (such as an EOF marker) is appended to each message; the receiver then continuously reads the stream until it detects this delimiter. If these boundaries are not defined properly, commands might be concatenated or split unpredictably, causing the receiver to misinterpret the data or execute incomplete commands._

3. Describe the general differences between stateful and stateless protocols.

_Stateful protocols maintain context between different requests, meaning the server keeps track of session information such as user authentication status, connection history, or previous command state. This continuity can simplify complex interactions where prior state is necessary, but it also requires the server to manage and store session data, which can increase resource usage and complicate scaling. In contrast, stateless protocols treat each request as an isolated transaction with no memory of previous interactions; every request must contain all the information required for processing. While this can simplify server design and improve scalability by avoiding the overhead of session management, it often requires additional mechanisms on the client side to preserve context across requests._

4. Our lecture this week stated that UDP is "unreliable". If that is the case, why would we ever use it?

_Even though UDP is considered "unreliable" because it does not guarantee delivery, order, or protection against duplicates, it remains popular due to its low overhead and minimal latency. Applications that require real-time data transmission—such as voice over IP (VoIP), online gaming, or video streaming—often prefer UDP because it allows for faster data transfer and can tolerate occasional packet loss. Moreover, the simplicity of UDP is an advantage in scenarios where the application itself can implement its own error handling and retransmission logic, or where the overhead of establishing a TCP connection would be prohibitive. Thus, the trade-off of unreliability is acceptable in cases where speed and efficiency are more critical than perfect delivery._

5. What interface/abstraction is provided by the operating system to enable applications to use network communications?

_The primary abstraction provided by operating systems for network communication is the sockets API. On Unix-like systems, this is typically the Berkeley Sockets interface, while on Windows it is provided by Winsock. The sockets API offers a uniform set of functions for creating, binding, connecting, sending, and receiving data over network protocols, hiding the underlying complexities of the network hardware and protocol details. This abstraction allows applications to work with network communications in a manner similar to file I/O, making it easier to build robust networked applications without needing to manage low-level details such as packet structure or retransmission mechanisms._
